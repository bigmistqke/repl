// Generated by dts-bundle-generator v9.5.1

/// <reference types="babel__core" />

export type FileType = "javascript" | "css" | "html" | "wasm" | "plain";
export interface Extension {
	transform?: Transform;
	type: FileType;
}
export interface FileUrls {
	invalidate(path: string): void;
	get(path: string, config?: {
		cached?: boolean;
	}): string | undefined;
}
export interface TransformConfig {
	path: string;
	source: string;
	fileUrls: FileUrls;
}
export type Transform = (config: TransformConfig) => () => string;
/**
 * Creates a registry for managing object URLs derived from a set of reactive file sources.
 *
 * For each file, an object URL is automatically created and kept up-to-date whenever the file
 * content or its transformation changes.
 *
 * @param readFile -
 * @param extensions - A map of file extensions to their transformation behavior and MIME types.
 *
 * @returns An API with the following methods:
 * - `get(path: string): string | undefined` — Returns the current managed object URL for the given path.
 *   The URL is automatically revoked and recreated when the file or its transformation changes.
 * - `create(path: string): string | undefined` — Manually creates a new object URL for the given path.
 *   The caller is responsible for revoking any URLs created with this method.
 * - `invalidate(path: string): void` — Forces `get(path)` to re-run and refresh its cached object URL.
 *
 * @example
 * const fileUrls = createFileUrlSystem(files, extensions);
 * const url = fileUrls.get('/src/index.js');
 * fileUrls.invalidate('/src/index.js'); // Forces a refresh
 */
export declare function createFileUrlSystem(readFile: (path: string) => string | Promise<string> | undefined, extensions: Record<string, Extension>): FileUrls;
/**
 * Creates a manager for downloading and tracking TypeScript declaration files (`.d.ts`)
 * for use with Monaco Editor, based on a given `tsconfig`.
 *
 * This utility supports dynamically adding downloaded types, aliasing module names,
 * and reactively watching for changes to the types and tsconfig.
 *
 * @param tsconfig - The initial TypeScript compiler options to extend and reactively update.
 *
 * @returns An API with the following methods:
 *
 * ### Configuration and State
 * - `tsconfig()` — Returns the current `tsconfig` including added paths for downloaded modules.
 * - `types()` — Returns the current record of downloaded declaration file contents.
 *
 * ### Modifications
 * - `addDeclaration(path, source, alias?)` — Adds a new declaration manually, optionally aliasing it to a module name.
 * - `downloadModule(name)` — Downloads types for the specified npm package and adds them automatically.
 *
 * ### Watchers
 * - `watchTsconfig(cb)` — Registers a callback to be called whenever the `tsconfig` changes.
 * - `watchTypes(cb)` — Registers a callback to be called whenever the types change.
 *
 * @example
 * const downloader = createMonacoTypeDownloader({
 *   target: monaco.languages.typescript.ScriptTarget.ESNext,
 *   moduleResolution: monaco.languages.typescript.ModuleResolutionKind.NodeJs,
 * });
 *
 * downloader.downloadModule('lodash');
 * downloader.watchTypes(types => {
 *   console.log('Updated types:', types);
 * });
 */
export declare function createMonacoTypeDownloader(tsconfig: Monaco.languages.typescript.CompilerOptions): {
	tsconfig(): {
		paths: {
			[x: string]: string[];
		};
		allowJs?: boolean;
		allowSyntheticDefaultImports?: boolean;
		allowUmdGlobalAccess?: boolean;
		allowUnreachableCode?: boolean;
		allowUnusedLabels?: boolean;
		alwaysStrict?: boolean;
		baseUrl?: string;
		charset?: string;
		checkJs?: boolean;
		declaration?: boolean;
		declarationMap?: boolean;
		emitDeclarationOnly?: boolean;
		declarationDir?: string;
		disableSizeLimit?: boolean;
		disableSourceOfProjectReferenceRedirect?: boolean;
		downlevelIteration?: boolean;
		emitBOM?: boolean;
		emitDecoratorMetadata?: boolean;
		experimentalDecorators?: boolean;
		forceConsistentCasingInFileNames?: boolean;
		importHelpers?: boolean;
		inlineSourceMap?: boolean;
		inlineSources?: boolean;
		isolatedModules?: boolean;
		jsx?: Monaco.languages.typescript.JsxEmit;
		keyofStringsOnly?: boolean;
		lib?: string[];
		locale?: string;
		mapRoot?: string;
		maxNodeModuleJsDepth?: number;
		module?: Monaco.languages.typescript.ModuleKind;
		moduleResolution?: Monaco.languages.typescript.ModuleResolutionKind;
		newLine?: Monaco.languages.typescript.NewLineKind;
		noEmit?: boolean;
		noEmitHelpers?: boolean;
		noEmitOnError?: boolean;
		noErrorTruncation?: boolean;
		noFallthroughCasesInSwitch?: boolean;
		noImplicitAny?: boolean;
		noImplicitReturns?: boolean;
		noImplicitThis?: boolean;
		noStrictGenericChecks?: boolean;
		noUnusedLocals?: boolean;
		noUnusedParameters?: boolean;
		noImplicitUseStrict?: boolean;
		noLib?: boolean;
		noResolve?: boolean;
		out?: string;
		outDir?: string;
		outFile?: string;
		preserveConstEnums?: boolean;
		preserveSymlinks?: boolean;
		project?: string;
		reactNamespace?: string;
		jsxFactory?: string;
		composite?: boolean;
		removeComments?: boolean;
		rootDir?: string;
		rootDirs?: string[];
		skipLibCheck?: boolean;
		skipDefaultLibCheck?: boolean;
		sourceMap?: boolean;
		sourceRoot?: string;
		strict?: boolean;
		strictFunctionTypes?: boolean;
		strictBindCallApply?: boolean;
		strictNullChecks?: boolean;
		strictPropertyInitialization?: boolean;
		stripInternal?: boolean;
		suppressExcessPropertyErrors?: boolean;
		suppressImplicitAnyIndexErrors?: boolean;
		target?: Monaco.languages.typescript.ScriptTarget;
		traceResolution?: boolean;
		resolveJsonModule?: boolean;
		types?: string[];
		typeRoots?: string[];
		esModuleInterop?: boolean;
		useDefineForClassFields?: boolean;
	};
	types(): Record<string, string>;
	addDeclaration(path: string, source: string, alias?: string): void;
	downloadModule(name: string): Promise<void>;
	watchTsconfig(cb: (tsconfig: Monaco.languages.typescript.CompilerOptions) => void): void;
	watchTypes(cb: (types: Record<string, string>) => void): void;
};
export type PackageJson = {
	main?: string;
	module?: string;
	browser?: string | Record<string, string>;
	exports?: ExportsField;
};
export type ExportsField = string | ExportsConditions | ExportsField[];
export type ExportsConditions = {
	"."?: ExportsField;
	browser?: ExportsField;
	import?: ExportsField;
	require?: ExportsField;
	default?: ExportsField;
	[key: string]: ExportsField | undefined;
};
export type ResolveConditions = {
	browser?: boolean;
	require?: boolean;
	import?: boolean;
};
export type ResolvedPaths = {
	[key: string]: string;
};
export declare function resolvePackageEntries(pkg: PackageJson, conditions?: ResolveConditions): ResolvedPaths;
export declare function createTransformModulePaths(ts: typeof TS, input: string): (transform: (path: string, isImport: boolean) => string | null) => string;
type Transform$1 = (source: string, path: string) => string;
export interface BabelConfig {
	babel?: typeof Babel | Promise<typeof Babel>;
	presets?: string[];
	plugins?: (string | babel.PluginItem)[];
	cdn?: string;
}
export declare function babelTransform(config: BabelConfig): Promise<Transform$1>;
export declare function transformHtmlWorker({ path, source, fileUrls }: TransformConfig): {
	select(selector: string, callback: (element: any) => void): any;
	/** Bind relative `href`-attribute of all `<link />` elements */
	transformLinkHref(): any;
	/** Bind relative `src`-attribute of all `<script />` elements */
	transformScriptSrc(): any;
	/** Transform content of all `<script type="module" />` elements */
	transformModuleScriptContent(transformJs: Transform): any;
	toString(): string;
};
export declare function transformHtml({ path, source, fileUrls }: TransformConfig): {
	select<T extends Element>(selector: string, callback: (element: T) => void): any;
	/** Bind relative `href`-attribute of all `<link />` elements */
	transformLinkHref(): any;
	/** Bind relative `src`-attribute of all `<script />` elements */
	transformScriptSrc(): any;
	/** Transform content of all `<script type="module" />` elements */
	transformModuleScriptContent(transformJs: Transform): any;
	toString(): string;
};
export declare function transformModulePaths(code: string, callback: (path: string, isImport: boolean) => string | null): string | undefined;
/**
 * Imports type definitions from a URL, checking if the types are already cached before importing.
 *
 * @param url The URL of the type definition to import.
 * @param [packageName] The package name associated with the type definitions.
 * @returns
 * @async
 */
export declare function downloadTypesFromUrl({ url, declarationFiles, cdn, }: {
	url: string;
	declarationFiles?: Record<string, string>;
	cdn?: string;
}): Promise<Record<string, string>>;
/**
 * Imports type definitions based on a package name by resolving it to a CDN path.
 *
 * @param packageName The package name whose types to import.
 * @returns
 * @async
 */
export declare function downloadTypesfromPackageName({ name, declarationFiles, cdn, }: {
	name: string;
	declarationFiles?: Record<string, string>;
	cdn?: string;
}): Promise<{
	path: string;
	types: Record<string, string>;
}>;
export declare function getExtension(path: string): string;
export declare function getName(path: string): string;
export declare function getParentPath(path: string): string;
export declare function normalizePath(path: string): string;
export declare function resolvePath(currentPath: string, relativePath: string): string;
export declare function isUrl(path: string): boolean;

export {};
